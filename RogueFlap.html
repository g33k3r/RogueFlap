<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Rogue Flap: Vector Overdrive</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        html, body {
            background-color: #000;
            color: #e2e8f0;
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        .game-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            perspective: 1000px; /* Create 3D rendering context */
        }
        canvas {
            background-color: #0c0c14;
            display: block;
            transform: translateZ(0); /* Trigger GPU acceleration */
            backface-visibility: hidden;
        }
        .screen-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.95);
            color: #fff;
            z-index: 10;
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            text-align: center;
            overflow-y: auto;
            transform: translateZ(0); /* Trigger GPU acceleration */
            backface-visibility: hidden;
        }
        #upgrade-screen {
             justify-content: flex-start;
             padding-top: 1.5rem;
        }
        .screen-overlay h1 {
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
        }
        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            width: 100%;
            max-width: 400px;
            margin-top: 1rem;
        }
        .upgrade-card {
            background-color: rgba(10, 20, 40, 0.5);
            border: 1px solid #0ff;
            box-shadow: 0 0 10px #0ff, inset 0 0 5px #0ff;
            border-radius: 8px;
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
         .upgrade-card h2 {
            font-size: 1rem;
            line-height: 1.5rem;
            margin-bottom: 0.25rem;
        }
        .upgrade-card p {
            font-size: 0.75rem;
        }
        .upgrade-btn {
            background-color: transparent;
            color: #0ff;
            border: 1px solid #0ff;
            box-shadow: 0 0 5px #0ff;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            margin-top: 0.5rem;
        }
        .upgrade-btn:hover:not(:disabled) {
            background-color: #0ff;
            color: #000;
            box-shadow: 0 0 15px #0ff;
        }
        .upgrade-btn:disabled {
            color: #4a5568;
            border-color: #4a5568;
            box-shadow: none;
            cursor: not-allowed;
        }
        #play-btn, #back-to-title-btn, #shop-options-btn {
            margin-top: 1.5rem;
            font-size: 1.2rem;
            padding: 0.75rem 1.5rem;
            color: #ff00ff;
            border-color: #ff00ff;
            box-shadow: 0 0 10px #ff00ff;
        }
        #play-btn:hover:not(:disabled), #back-to-title-btn:hover:not(:disabled), #shop-options-btn:hover:not(:disabled) {
            background-color: #ff00ff;
            color: #000;
            box-shadow: 0 0 20px #ff00ff;
        }
    </style>
</head>
<body>

<div class="game-wrapper">
    <canvas id="gameCanvas"></canvas>
</div>

<!-- Options Screen -->
<div id="options-screen" class="screen-overlay">
    <div>
        <h1 class="text-3xl mb-6">Options</h1>
        <div class="upgrade-card">
            <h2 class="text-xl">Music Volume</h2>
            <input type="range" id="volume-slider" min="0" max="100" value="80" class="w-full mt-2">
        </div>
        <div class="upgrade-card mt-4">
             <button id="mute-btn" class="upgrade-btn w-full">Mute</button>
        </div>
        <button id="back-to-title-btn" class="upgrade-btn">Back</button>
    </div>
</div>

<!-- Upgrade Screen -->
<div id="upgrade-screen" class="screen-overlay">
    <div>
        <h1 class="text-3xl mb-1">Ship Hangar</h1>
        <p class="text-sm">Last Score: <span id="last-score-val">0</span> | Current Level: <span id="current-level-val">0</span></p>
        <p class="text-md mb-2">Total Coins: <span id="total-coins-val">0</span></p>
        
        <div class="upgrade-grid">
            <div class="upgrade-card">
                <h2>üí• Laser</h2>
                <p>Cost: <span id="laser-cost">25</span> | Level: <span id="laser-level">1</span></p>
                <button id="buy-laser-btn" class="upgrade-btn">Upgrade</button>
            </div>
            
            <div class="upgrade-card">
                <h2>üõ∞Ô∏è Missiles</h2>
                <p>Cost: <span id="missile-cost">75</span> | Level: <span id="missile-level">0</span></p>
                <button id="buy-missile-btn" class="upgrade-btn">Upgrade</button>
            </div>
            
            <div class="upgrade-card">
                <h2>üí∞ Coins</h2>
                <p>Cost: <span id="coin-cost">50</span> | Level: <span id="coin-level">x1</span></p>
                <button id="buy-coin-btn" class="upgrade-btn">Upgrade</button>
            </div>

            <div class="upgrade-card">
                <h2>üõ°Ô∏è Shield</h2>
                <p>Cost: <span id="shield-cost">25</span> | Level: <span id="shield-level">0</span></p>
                <button id="buy-shield-btn" class="upgrade-btn">Upgrade</button>
            </div>
             <div class="upgrade-card">
                <h2>üß≤ Magnet</h2>
                <p>Cost: <span id="magnet-cost">100</span></p>
                <button id="buy-magnet-btn" class="upgrade-btn">Buy</button>
            </div>
        </div>

        <button id="play-btn" class="upgrade-btn">Engage</button>
        <button id="shop-options-btn" class="upgrade-btn">Options</button>
    </div>
</div>


<script>
// --- Game Setup ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const upgradeScreen = document.getElementById('upgrade-screen');
const optionsScreen = document.getElementById('options-screen');

const GAME_WIDTH = 400; // Virtual width
const GAME_HEIGHT = 600; // Virtual height
let scale = 1;
let offsetX = 0;
let offsetY = 0;

// --- Game State & Difficulty ---
let gameState = 'TITLE', previousGameState = 'TITLE', frame = 0, score = 0, nextPipeFrame = 0, bossFightTriggeredForScore = -1;
let screenShake = { intensity: 0, duration: 0 };
let boss;
let transitionTimer = 0;
let audioInitialized = false;

// --- Player Stats & Upgrades ---
const SAVE_KEY = 'rogueFlapStatsGW_v22'; 
let stats = { 
    totalCoins: 0, 
    laserLevel: 1, 
    missileLevel: 0,
    shieldLevel: 0,
    coinValueLevel: 1,
    hasMagnet: false,
    currentScore: 0,
    currentShieldHp: 0,
    lastScore: 0,
    get laserDamage() { return 1 + (this.laserLevel - 1) * 0.5; },
    get missileCooldownTime() { return this.missileLevel > 0 ? Math.max(10, 90 - (this.missileLevel - 1) * 10) : Infinity; },
    get coinValue() { return this.coinValueLevel; }
};
const BASE_FLAP_POWER = 6;
const BASE_GRAVITY = 0.3;

let audioSettings = { volume: -10, mute: false };

function getUpgradeCost(base, lvl) { return Math.floor(base * Math.pow(1.5, lvl - 1)); }
function getShieldCost(lvl) { return Math.floor(25 * Math.pow(4, lvl));}
function saveStats() { localStorage.setItem(SAVE_KEY, JSON.stringify(stats)); }
function loadStats() { const s = localStorage.getItem(SAVE_KEY); if(s) stats = {...stats, ...JSON.parse(s)}; }
function saveAudioSettings() { localStorage.setItem('rogueFlapAudio_v22', JSON.stringify(audioSettings)); }
function loadAudioSettings() { const s = localStorage.getItem('rogueFlapAudio_v22'); if(s) audioSettings = {...audioSettings, ...JSON.parse(s)}; }


// --- UI Elements ---
const backToTitleBtn = document.getElementById('back-to-title-btn');
const volumeSlider = document.getElementById('volume-slider');
const muteBtn = document.getElementById('mute-btn');
const playBtn = document.getElementById('play-btn'), 
      buyLaserBtn = document.getElementById('buy-laser-btn'),
      buyMissileBtn = document.getElementById('buy-missile-btn'),
      buyShieldBtn = document.getElementById('buy-shield-btn'),
      buyCoinBtn = document.getElementById('buy-coin-btn'),
      buyMagnetBtn = document.getElementById('buy-magnet-btn'),
      shopOptionsBtn = document.getElementById('shop-options-btn');

function updateUpgradeUI() {
    document.getElementById('last-score-val').textContent = stats.lastScore;
    document.getElementById('total-coins-val').textContent = stats.totalCoins;
    document.getElementById('current-level-val').textContent = stats.currentScore;
    playBtn.textContent = stats.currentScore > 0 ? "Next Round" : "Start Run";
    
    document.getElementById('laser-level').textContent = stats.laserLevel;
    const laserCost = getUpgradeCost(25, stats.laserLevel);
    document.getElementById('laser-cost').textContent = laserCost;
    buyLaserBtn.disabled = stats.totalCoins < laserCost;

    document.getElementById('missile-level').textContent = stats.missileLevel;
    const missileCost = getUpgradeCost(75, stats.missileLevel + 1);
    buyMissileBtn.textContent = stats.missileLevel >= 9 ? "Max Level" : "Upgrade";
    document.getElementById('missile-cost').textContent = missileCost;
    buyMissileBtn.disabled = stats.totalCoins < missileCost || stats.missileLevel >= 9;

    document.getElementById('shield-level').textContent = stats.shieldLevel;
    const shieldCost = getShieldCost(stats.shieldLevel);
    document.getElementById('shield-cost').textContent = shieldCost;
    buyShieldBtn.textContent = stats.shieldLevel >= 5 ? "Max Level" : "Upgrade";
    buyShieldBtn.disabled = stats.totalCoins < shieldCost || stats.shieldLevel >= 5;

    document.getElementById('coin-level').textContent = `x${stats.coinValue}`;
    const coinCost = getUpgradeCost(50, stats.coinValueLevel);
    document.getElementById('coin-cost').textContent = coinCost;
    buyCoinBtn.disabled = stats.totalCoins < coinCost;
    
    buyMagnetBtn.disabled = stats.hasMagnet || stats.totalCoins < 100;
    buyMagnetBtn.textContent = stats.hasMagnet ? "Owned" : "Buy";
}
function buyUpgrade(costFunc, levelProp, effect) {
    const cost = costFunc(stats[levelProp]);
    if (stats.totalCoins >= cost) {
        stats.totalCoins -= cost;
        stats[levelProp]++;
        saveStats();
        updateUpgradeUI();
        if(effect) effect();
    }
}


// --- Audio Engine ---
let titlePlayer, mainPlayer, bossPlayer;
let musicFader, mainGain, bossGain;
let currentMusicTheme = '';

if (typeof Tone !== 'undefined') {
    Tone.context.latencyHint = 'playback';
}

async function initAudio() {
    if (audioInitialized) return;
    audioInitialized = true; // Prevent re-entry
    if(typeof Tone === 'undefined') return;

    await Tone.start();
    
    musicFader = new Tone.CrossFade(0).toDestination();

    titlePlayer = new Tone.Player({
        url: "https://cdn.jsdelivr.net/gh/g33k3r/MyCDN@main/Echoes-of-the-Void.ogg",
        loop: true,
    }).connect(musicFader.a);
    
    mainGain = new Tone.Gain(0).connect(musicFader.b);
    bossGain = new Tone.Gain(0).connect(musicFader.b);

    mainPlayer = new Tone.Player({
        url: "https://cdn.jsdelivr.net/gh/g33k3r/MyCDN@main/Hypernova-Pulse.ogg",
        loop: true,
    }).connect(mainGain);

    bossPlayer = new Tone.Player({
        url: "https://cdn.jsdelivr.net/gh/g33k3r/MyCDN@main/Battle-in-the-Machine-Core.ogg",
        loop: true,
    }).connect(bossGain);
    
    await Tone.loaded();

    titlePlayer.start();
    mainPlayer.start();
    bossPlayer.start();
    
    volumeSlider.value = (audioSettings.volume + 40) / 0.4;
    Tone.Destination.volume.value = audioSettings.volume;
    Tone.Destination.mute = audioSettings.mute;
    muteBtn.textContent = audioSettings.mute ? "Unmute" : "Mute";
    
    updateMusicByGameState();
}

function switchMusic(theme) {
    if(!audioInitialized || currentMusicTheme === theme) return;
    
    currentMusicTheme = theme;

    if(theme === 'title') {
        musicFader.fade.rampTo(0, 0.5);
    } else if (theme === 'main') {
        musicFader.fade.rampTo(1, 0.5);
        mainGain.gain.rampTo(1, 0.5);
        bossGain.gain.rampTo(0, 0.5);
    } else if (theme === 'boss') {
        musicFader.fade.rampTo(1, 0.5);
        mainGain.gain.rampTo(0, 0.5);
        bossGain.gain.rampTo(1, 0.5);
    }
}

function updateMusicByGameState() {
    if (!audioInitialized) return;
    switch(gameState) {
        case 'TITLE':
        case 'UPGRADE':
            switchMusic('title');
            break;
        case 'GET_READY':
        case 'PLAYING':
        case 'POST_BOSS_TRANSITION':
            switchMusic('main');
            break;
        case 'BOSS_TRANSITION':
        case 'BOSS':
            switchMusic('boss');
            break;
        default:
            switchMusic('title');
            break;
    }
}


// --- Event Listeners ---
playBtn.onclick = () => { startRound(); };
backToTitleBtn.onclick = () => {
    gameState = previousGameState;
    updateMusicByGameState();
};
volumeSlider.oninput = () => {
    if(!audioInitialized) return;
    const db = (volumeSlider.value / 100) * 40 - 40;
    Tone.Destination.volume.value = db;
    audioSettings.volume = db;
    saveAudioSettings();
};
muteBtn.onclick = () => {
    audioSettings.mute = !audioSettings.mute;
    if (audioInitialized) {
        Tone.Destination.mute = audioSettings.mute;
    }
    muteBtn.textContent = audioSettings.mute ? "Unmute" : "Mute";
    saveAudioSettings();
};
shopOptionsBtn.onclick = () => {
    previousGameState = 'UPGRADE';
    gameState = 'OPTIONS';
};
buyLaserBtn.onclick = () => buyUpgrade(c => getUpgradeCost(25,c), 'laserLevel', () => triggerScreenShake(3,8));
buyMissileBtn.onclick = () => buyUpgrade(c => getUpgradeCost(75, c + 1), 'missileLevel', () => triggerScreenShake(5,10));
buyShieldBtn.onclick = () => buyUpgrade(getShieldCost, 'shieldLevel', () => triggerScreenShake(5,10));
buyCoinBtn.onclick = () => buyUpgrade(c => getUpgradeCost(50, c), 'coinValueLevel', () => triggerScreenShake(3,8));
buyMagnetBtn.onclick = () => {
    const cost = 100;
    if(stats.totalCoins >= cost && !stats.hasMagnet) {
        stats.totalCoins -= cost;
        stats.hasMagnet = true;
        saveStats();
        updateUpgradeUI();
        triggerScreenShake(5, 10);
    }
};

['mousedown', 'touchstart'].forEach(evt => {
    canvas.addEventListener(evt, (e) => {
        if (e.type === 'touchstart') e.preventDefault();
        handleInput(e.type === 'touchstart' ? e.touches[0] : e);
    });
});

async function handleInput(e) {
    if (!audioInitialized) {
       await initAudio();
    }
    
    const rect = canvas.getBoundingClientRect();
    const rawX = e.clientX - rect.left;
    const rawY = e.clientY - rect.top;

    const x = (rawX - offsetX) / scale;
    const y = (rawY - offsetY) / scale;

    if (gameState === 'TITLE') {
        if (isInside(x, y, buttons.start)) {
            if (stats.currentScore > 0) {
                gameState = 'UPGRADE';
                updateMusicByGameState();
            } else {
                startRound();
            }
        } else if (isInside(x, y, buttons.options)) {
            previousGameState = 'TITLE';
            gameState = 'OPTIONS';
        }
    } else if (gameState === 'GET_READY') {
        gameState = 'PLAYING';
        player.gravityActive = true;
        player.flap();
    } else if (gameState === 'PLAYING' || gameState === 'BOSS_TRANSITION') {
        player.flap();
    } else if (gameState === 'BOSS') {
        player.shoot();
    }
}

// --- Graphics & Effects Classes ---
let particles = [];
let floatingTexts = [];
class FloatingText {
    constructor(x, y, text, color) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.life = 60; 
        this.vy = -1; 
        this.alpha = 1;
    }
    update() {
        this.y += this.vy;
        this.life--;
        this.alpha = Math.max(0, this.life / 60);
    }
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.font = '12px "Press Start 2P"';
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 5;
        ctx.fillText(this.text, this.x, this.y);
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color, size, life) { this.x=x;this.y=y;this.color=color;this.size=size;this.life=life;this.initialLife=life;this.vx=(Math.random()-.5)*8;this.vy=(Math.random()-.5)*8;this.friction=.98;this.gravity=.05; }
    update() { this.vy+=this.gravity;this.vx*=this.friction;this.vy*=this.friction;this.x+=this.vx;this.y+=this.vy;this.life--; }
    draw(ctx){ctx.save();ctx.globalAlpha=Math.max(0,(this.life/this.initialLife)*(Math.random()>.1?1:.8));ctx.fillStyle=this.color;ctx.shadowColor=this.color;ctx.shadowBlur=this.size*2;ctx.beginPath();ctx.arc(this.x,this.y,this.size,0,Math.PI*2);ctx.fill();ctx.restore();}
}
class Star {
    constructor(layer){this.layer=layer;this.x=Math.random()*GAME_WIDTH;this.y=Math.random()*GAME_HEIGHT;this.speed=.1+(this.layer*.15);this.size=.5+(this.layer*.5);}
    update(){this.x-=this.speed;if(this.x<0)this.x=GAME_WIDTH;}
    draw(ctx){ctx.fillStyle=`rgba(200,220,255,${this.size*.3})`;ctx.fillRect(this.x,this.y,this.size,this.size);}
}
let stars = [ ...Array.from({length: 50}, () => new Star(1)), ...Array.from({length: 30}, () => new Star(2)), ...Array.from({length: 15}, () => new Star(3))];
function triggerScreenShake(intensity, duration) { screenShake.intensity = Math.max(screenShake.intensity, intensity); screenShake.duration = Math.max(screenShake.duration, duration); }

// --- Projectile Classes ---
let playerBullets = [], missiles = [];
class PlayerBullet {
    constructor(x, y) { this.x=x; this.y=y; this.size=4; this.speed=8; }
    update() { this.x -= this.speed; }
    draw(ctx) {
        ctx.save(); ctx.fillStyle='#00ffff'; ctx.shadowColor='#00ffff'; ctx.shadowBlur=10;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    }
}
class Missile {
    constructor(x,y) { this.x=x; this.y=y; this.size=6; this.speed=3; this.angle=0; }
    update() {
        if (boss) {
            const targetAngle = Math.atan2(boss.y - this.y, boss.x - this.x);
            this.angle += (targetAngle - this.angle) * 0.1;
        }
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        this.speed += 0.1;
        if(frame % 3 === 0) particles.push(new Particle(this.x, this.y, '#ff8c00', 2, 10));
    }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = '#ff8c00'; ctx.shadowColor = '#ff8c00'; ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.moveTo(this.size, 0); ctx.lineTo(-this.size, -this.size/2); ctx.lineTo(-this.size, this.size/2);
        ctx.closePath(); ctx.fill();
        ctx.restore();
    }
}

// --- Game Object Classes ---
class Player {
    constructor(startingShields) {
        this.x = 60; this.y = GAME_HEIGHT / 2; this.vy = 0; this.width = 30; this.height = 20; this.angle = 0;
        this.shieldHp = startingShields;
        this.invincible = false; this.invincibleTimer = 0;
        this.gravityActive = false;
        this.flapCooldown = 0; this.idleBob = Math.random() * Math.PI * 2;
        this.bossLives = 3; this.shootCooldown = 0; this.missileCooldown = 0;
        this.transitionStage = ''; this.vx = 0;
    }
    update() {
        if(gameState === 'POST_BOSS_TRANSITION'){
            this.y += this.vy;
            if(this.transitionStage === 'returning') {
                const targetX = 60;
                this.x += (targetX - this.x) * 0.05;
                if(Math.abs(this.x - targetX) < 1) {
                    this.transitionStage = 'launching';
                    this.vx = 15;
                    this.vy = -2;
                    for(let i=0; i<100; i++) particles.push(new Particle(this.x, this.y + this.height/2, '#00ffff', Math.random()*3+1, 30));
                }
            } else if (this.transitionStage === 'launching') {
                this.x += this.vx;
            }
            return;
        }

        if (this.gravityActive) {
             this.vy += (gameState === 'BOSS' ? 0.1 : BASE_GRAVITY);
        }
        this.y += this.vy;
        this.angle = this.vy * 0.05;
        if(gameState !== 'POST_BOSS_TRANSITION') {
            if (this.y + this.height > GAME_HEIGHT) { this.y = GAME_HEIGHT - this.height; }
            if (this.y < 0) { this.y = 0; }
        }
        
        if (this.invincibleTimer > 0) this.invincibleTimer--; else this.invincible = false;
        if (this.flapCooldown > 0) this.flapCooldown--;
        if (this.shootCooldown > 0) this.shootCooldown--;
        if (this.missileCooldown > 0) this.missileCooldown--;
        this.idleBob += 0.1;

        if(gameState === 'BOSS_TRANSITION') {
            const targetX = GAME_WIDTH - 80;
            this.x += (targetX - this.x) * 0.05;
        }

        if (gameState === 'BOSS' && stats.missileLevel > 0 && this.missileCooldown <= 0) {
            missiles.push(new Missile(this.x, this.y + this.height/2));
            this.missileCooldown = stats.missileCooldownTime;
        }
    }
    draw(ctx) { 
        if(this.invincible&&Math.floor(frame/3)%2===0)return;ctx.save();ctx.translate(this.x+this.width/2,this.y+this.height/2+Math.sin(this.idleBob)*1.5);ctx.rotate(this.angle);ctx.shadowColor='#00ffff';ctx.shadowBlur=15;if(this.flapCooldown>0){const e=(this.flapCooldown/10)*18,g=ctx.createRadialGradient(0,0,0,0,0,e);g.addColorStop(0,'rgba(255,255,255,1)');g.addColorStop(.2,'rgba(0,255,255,.7)');g.addColorStop(1,'rgba(0,255,255,0)');ctx.fillStyle=g;ctx.beginPath();ctx.arc(-this.width*.7,0,e,0,Math.PI*2);ctx.fill();}
        ctx.fillStyle=this.invincible?'#ff00ff':'#00ffff';ctx.beginPath();ctx.moveTo(-this.width/2,-this.height/2);ctx.lineTo(this.width/2,0);ctx.lineTo(-this.width/2,this.height/2);ctx.closePath();ctx.fill();ctx.fillStyle='#ffffff';ctx.shadowBlur=5;ctx.beginPath();ctx.arc(0,0,4,0,Math.PI*2);ctx.fill();ctx.restore();
        if (this.shieldHp > 0) {
            const centerX = this.x + this.width / 2;
            const centerY = this.y + this.height / 2;
            const radius = this.width * 0.75;

            // Define colors per shield level
            const shieldColors = ['rgba(255,0,0,1)', 'rgba(255,127,0,1)', 'rgba(255,255,0,1)', 'rgba(0,255,0,1)', 'rgba(0,255,255,1)'];
            const color = this.shieldHp >= 5 ? `hsl(${frame * 3 % 360}, 100%, 50%)` : shieldColors[this.shieldHp - 1];

            ctx.save();

            // --- 1. Glowing Aura Background ---
            const auraGradient = ctx.createRadialGradient(centerX, centerY, radius * 0.3, centerX, centerY, radius + 15);
            auraGradient.addColorStop(0, color.replace('1)', '0.6)'));
            auraGradient.addColorStop(1, color.replace('1)', '0.0)'));

            ctx.fillStyle = auraGradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius + 15, 0, Math.PI * 2);
            ctx.fill();

            // --- 2. Shield Ring with Pulse ---
            ctx.shadowColor = color;
            ctx.shadowBlur = 25;

            const ringGradient = ctx.createRadialGradient(centerX, centerY, radius * 0.5, centerX, centerY, radius);
            ringGradient.addColorStop(0, 'white');
            ringGradient.addColorStop(1, color);

            ctx.strokeStyle = ringGradient;
            ctx.lineWidth = 6 + Math.sin(frame * 0.2) * 2;

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }
    }
    flap() { this.vy = -BASE_FLAP_POWER; this.flapCooldown = 10; triggerScreenShake(2, 5); }
    shoot() {
        if (this.shootCooldown > 0) return;
        this.vy = -4.5;
        playerBullets.push(new PlayerBullet(this.x, this.y + this.height/2));
        this.shootCooldown = 10;
        triggerScreenShake(1, 3);
    }
    takeDamage() {
        if(this.invincible) return;
        this.bossLives--;
        this.invincible = true;
        this.invincibleTimer = 120;
        triggerScreenShake(10, 15);
        if (this.bossLives < 0) {
            gameOver();
        }
    }
    breakShield() { 
        if (this.shieldHp > 0) { 
            this.shieldHp--;
            this.invincible = true; 
            this.invincibleTimer = 120; 
            triggerScreenShake(10, 15); 
            for(let i=0; i<50; i++) particles.push(new Particle(this.x + this.width/2, this.y + this.height/2, '#00ffff', Math.random() * 4 + 2, 50)); 
            return true; 
        } 
        return false; 
    }
}

class Pipe {
    constructor(gap){this.gap=gap;this.top=Math.random()*(GAME_HEIGHT/2)+75;this.bottom=this.top+this.gap;this.x=GAME_WIDTH;this.width=20;this.speed=3;this.counted=false;}
    update(){this.x-=this.speed;}
    draw(ctx){ctx.save();const p=.7+Math.sin(frame*.05+this.x*.1)*.3;ctx.strokeStyle='#ff007f';ctx.lineWidth=5;ctx.shadowColor='#ff007f';ctx.shadowBlur=15*p;ctx.globalAlpha=p;ctx.beginPath();ctx.moveTo(this.x,0);ctx.lineTo(this.x,this.top);ctx.moveTo(this.x+this.width,0);ctx.lineTo(this.x+this.width,this.top);ctx.moveTo(this.x,this.top);ctx.lineTo(this.x+this.width,this.top);ctx.moveTo(this.x,GAME_HEIGHT);ctx.lineTo(this.x,this.bottom);ctx.moveTo(this.x+this.width,GAME_HEIGHT);ctx.lineTo(this.x+this.width,this.bottom);ctx.moveTo(this.x,this.bottom);ctx.lineTo(this.x+this.width,this.bottom);ctx.stroke();ctx.restore();}
}

class Collectible {
    constructor(pipe,type){this.type=type;this.x=pipe.x+pipe.width/2;this.y=pipe.top+pipe.gap/2;this.speed=pipe.speed;this.size=type==='coin'?10:15;this.angle=0;}
    update(){this.x-=this.speed;this.angle+=.1;}
    draw(ctx){ctx.save();ctx.translate(this.x,this.y);ctx.rotate(this.angle);if(this.type==='coin'){ctx.strokeStyle='#ffff00';ctx.lineWidth=2;ctx.shadowColor='#ffff00';ctx.shadowBlur=10;ctx.beginPath();ctx.moveTo(0,-this.size);ctx.lineTo(this.size,0);ctx.lineTo(0,this.size);ctx.lineTo(-this.size,0);ctx.closePath();ctx.stroke();}ctx.restore();}
}
let pipes = [], collectibles = [];

class Boss {
    constructor(level) {
        this.level = level;
        this.x = -100; this.y = GAME_HEIGHT / 2;
        this.size = 40 + level * 5;
        this.maxHp = 20 + level * 20; 
        this.hp = this.maxHp;
        this.projectiles = []; this.shootCooldown = 0;
        this.targetY = this.y; this.entrySpeed = 2; this.angle = 0;
    }
    update() {
        this.angle += 0.005 * (1 + this.level * 0.5);
        if (this.x < 50) { this.x += this.entrySpeed; return; }
        this.y += (this.targetY - this.y) * 0.05;
        if (Math.abs(this.targetY - this.y) < 1) { this.targetY = Math.random() * (GAME_HEIGHT - 200) + 100; }
        this.shootCooldown--;
        if (this.shootCooldown <= 0) {
            this.shoot();
            this.shootCooldown = Math.max(20, 90 - this.level * 15);
        }
        this.projectiles.forEach(p => p.update());
        this.projectiles = this.projectiles.filter(p => p.x < GAME_WIDTH);
    }
    shoot() {
        if(this.level === 0) {
            this.projectiles.push(new BossProjectile(this.x, this.y, this.level));
        } else if (this.level === 1) {
             this.projectiles.push(new BossProjectile(this.x, this.y, this.level, {angle: -0.1}));
             this.projectiles.push(new BossProjectile(this.x, this.y, this.level, {angle: 0.1}));
        } else {
            for(let i=0; i<3; i++) {
                setTimeout(() => {
                    if(this.hp > 0) this.projectiles.push(new BossProjectile(this.x, this.y, this.level));
                }, i * 100);
            }
        }
    }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y); ctx.rotate(this.angle);
        
        if (this.level === 0) {
             ctx.strokeStyle = '#ff007f'; ctx.lineWidth = 4; ctx.shadowColor = '#ff007f'; ctx.shadowBlur = 20;
             ctx.beginPath();
             for (let i = 0; i < 8; i++) {
                 const angle = (i / 8) * Math.PI * 2;
                 const xPos = Math.cos(angle) * this.size; const yPos = Math.sin(angle) * this.size;
                 if (i === 0) ctx.moveTo(xPos, yPos); else ctx.lineTo(xPos, yPos);
             }
             ctx.closePath(); ctx.stroke();
        } else if (this.level === 1) {
            ctx.strokeStyle = '#ff4da6'; ctx.lineWidth = 5; ctx.shadowColor = '#ff4da6'; ctx.shadowBlur = 25;
            ctx.beginPath();
            ctx.moveTo(0, -this.size); ctx.lineTo(this.size, 0);
            ctx.lineTo(0, this.size); ctx.lineTo(-this.size, 0);
            ctx.closePath(); ctx.stroke();
        } else {
            ctx.strokeStyle = '#ff80df'; ctx.lineWidth = 6; ctx.shadowColor = '#ff80df'; ctx.shadowBlur = 30;
            ctx.beginPath();
            for (let i = 0; i < 10; i++) {
                 const radius = i % 2 === 0 ? this.size : this.size / 2;
                 const angle = (i / 10) * Math.PI * 2;
                 const xPos = Math.cos(angle) * radius; const yPos = Math.sin(angle) * radius;
                 if (i === 0) ctx.moveTo(xPos, yPos); else ctx.lineTo(xPos, yPos);
             }
             ctx.closePath(); ctx.stroke();
        }
        
        ctx.restore();
        ctx.save();
        const pulse = 0.5 + Math.sin(frame * 0.1) * 0.5;
        ctx.fillStyle = `rgba(255, 0, 127, ${pulse})`;
        ctx.shadowColor = '#ff007f'; ctx.shadowBlur = 25;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
        this.projectiles.forEach(p => p.draw(ctx));
    }
    takeDamage(damage) {
        this.hp -= damage; triggerScreenShake(2, 5);
        for(let i=0; i<5; i++) particles.push(new Particle(this.x + (Math.random()-.5)*this.size*2, this.y + (Math.random()-.5)*this.size*2, '#ffffff', Math.random()*3+1, 20));
        if (this.hp <= 0) { endBossFight(); }
    }
}

class BossProjectile {
    constructor(x,y, level, options={}) {
        this.x=x; this.y=y; this.size=6 + level;
        this.speed=4 + level * 0.5;
        this.angle = options.angle || 0;
    }
    update() {
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
    }
    draw(ctx) {
        ctx.save(); ctx.fillStyle = '#ff007f'; ctx.shadowColor = '#ff007f'; ctx.shadowBlur = 10;
        ctx.fillRect(this.x - this.size, this.y - this.size, this.size*2, this.size*2);
        ctx.restore();
    }
}

// --- Game Logic ---
function initiateBossTransition() {
    gameState = 'BOSS_TRANSITION';
    updateMusicByGameState();
    bossFightTriggeredForScore = score;
    transitionTimer = 300;
}

function startBossFight() {
    gameState = 'BOSS';
    updateMusicByGameState();
    screenShake = { intensity: 0, duration: 0 };
    const bossLevel = Math.floor(score / 25);
    boss = new Boss(bossLevel);
    player.bossLives = 3;
    playerBullets = []; missiles = [];
    triggerScreenShake(15, 20);
}

function endBossFight() {
    triggerScreenShake(25, 30);
    stats.currentScore = score + 1;
    stats.totalCoins += 100;
    floatingTexts.push(new FloatingText(boss.x, boss.y, "+100", '#ffff00'));
    for(let i=0; i<200; i++) particles.push(new Particle(boss.x, boss.y, '#ff007f', Math.random() * 6, 100));
    stats.currentShieldHp = player.shieldHp; 
    saveStats();
    boss = null;
    gameState = 'POST_BOSS_TRANSITION';
    updateMusicByGameState();
    transitionTimer = 180;
    player.transitionStage = 'returning';
    player.gravityActive = false;
    player.vy = 0;
    updateUpgradeUI();
}

function handlePlayingState() {
    player.update();
    handlePipesAndCollectibles();
    handleCollectiblesLogic();
    player.draw(ctx);
    if (player.gravityActive && checkCollisions()) gameOver();
    if (score > 0 && score % 25 === 0 && score !== bossFightTriggeredForScore) {
        initiateBossTransition();
    }
}

function handleBossTransitionState() {
    transitionTimer--;
    player.update();
    handlePipesAndCollectibles(true);
    handleCollectiblesLogic();
    player.draw(ctx);
    if (transitionTimer <= 0) {
        startBossFight();
    }
}

function handlePostBossTransitionState() {
    player.update();
    handleCollectiblesLogic();
    player.draw(ctx);
    if (player.transitionStage === 'returning' && Math.abs(player.x - 60) < 1) {
        player.transitionStage = 'launching';
        player.vx = 15;
        player.vy = -2;
        for(let i=0; i<100; i++) {
            particles.push(new Particle(this.x, this.y + this.height/2, '#00ffff', Math.random()*3+1, 30));
        }
    }

    if (player.transitionStage === 'launching' && player.x > GAME_WIDTH + player.width) {
        gameState = 'UPGRADE';
        updateMusicByGameState();
    }
}

function handleBossState() {
    if (!boss) return;
    player.update();
    boss.update();
    
    playerBullets.forEach(b => b.update());
    playerBullets = playerBullets.filter(b => b.x > 0);
    
    missiles.forEach(m => m.update());
    missiles = missiles.filter(m => m.x > 0 && m.x < GAME_WIDTH && m.y > 0 && m.y < GAME_HEIGHT);

    for (let i = playerBullets.length - 1; i >= 0; i--) {
        const b = playerBullets[i];
        if (boss && Math.hypot(b.x - boss.x, b.y - boss.y) < boss.size) {
            playerBullets.splice(i, 1);
            boss.takeDamage(stats.laserDamage);
        }
    }

    for (let i = missiles.length - 1; i >= 0; i--) {
        const m = missiles[i];
         if (boss && Math.hypot(m.x - boss.x, m.y - boss.y) < boss.size) {
            missiles.splice(i, 1);
            boss.takeDamage(5);
            for(let j=0; j<20; j++) particles.push(new Particle(m.x, m.y, '#ff8c00', Math.random() * 4, 30));
        }
    }

    if (!boss) return; 
    for (let i = boss.projectiles.length - 1; i >= 0; i--) {
        const p = boss.projectiles[i];
        if (!player.invincible && p.x > player.x && p.x < player.x + player.width && p.y > player.y && p.y < player.y + player.height) {
            boss.projectiles.splice(i, 1);
            if (!player.breakShield()) {
                player.takeDamage();
            }
        }
    }
    
    if (!player.invincible && (player.y <= 0 || player.y + player.height >= GAME_HEIGHT)) {
        if (!player.breakShield()) {
           player.takeDamage();
        }
    }
    
    player.draw(ctx);
    boss.draw(ctx);
    playerBullets.forEach(b => b.draw(ctx));
    missiles.forEach(m => m.draw(ctx));
}

function handlePipesAndCollectibles(isTransition = false) {
    if (player.gravityActive && !isTransition && frame >= nextPipeFrame) {
        const difficultyProgress = Math.min(1, score / 50);
        const gap = 180 - (180 - 120) * difficultyProgress;
        const interval = 120 - (120 - 80) * difficultyProgress;
        const newPipe = new Pipe(gap);
        pipes.push(newPipe);
        if (Math.random() < 0.6) {
            collectibles.push(new Collectible(newPipe, 'coin'));
        }
        nextPipeFrame = frame + interval;
    }
    pipes.forEach(p => { p.update(); p.draw(ctx); if (gameState === 'PLAYING' && !p.counted && p.x < player.x) { score++; p.counted = true; }});
    pipes = pipes.filter(p => p.x + p.width > 0);
}

function handleCollectiblesLogic() {
    for(let i = collectibles.length - 1; i >= 0; i--) {
        let c = collectibles[i];
        if (stats.hasMagnet && Math.hypot(player.x - c.x, player.y - c.y) < 100) {
            const angle = Math.atan2(player.y + player.height/2 - c.y, player.x + player.width/2 - c.x);
            c.x += Math.cos(angle) * 5; c.y += Math.sin(angle) * 5;
        }
        c.update(); c.draw(ctx);
        const dist = Math.hypot(player.x + player.width/2 - c.x, player.y + player.height/2 - c.y);
        if (dist < player.width/2 + c.size + 15) {
            stats.totalCoins += stats.coinValue;
            floatingTexts.push(new FloatingText(c.x, c.y, `+${stats.coinValue}`, '#ffff00'));
            for(let j=0; j<8; j++) particles.push(new Particle(c.x, c.y, '#ffff00', Math.random() * 3, 20));
            collectibles.splice(i, 1);
        } else if (c.x + c.size < 0) { collectibles.splice(i, 1); }
    }
}

function drawHud() {
    if(gameState==='BOSS' && boss){
        const barWidth = GAME_WIDTH-40, barX = 20, barY = 20;
        ctx.save();
        ctx.fillStyle='rgba(255,0,127,.2)'; ctx.fillRect(barX,barY,barWidth,20);
        const hpWidth = Math.max(0, (boss.hp / boss.maxHp) * barWidth);
        ctx.fillStyle='#ff007f'; ctx.shadowColor='#ff007f'; ctx.shadowBlur=10; ctx.fillRect(barX,barY,hpWidth,20);
        ctx.restore();
        for(let i=0; i<player.bossLives; i++) {
            ctx.save(); ctx.translate(30 + i * 25, GAME_HEIGHT - 30); ctx.shadowColor='#00ffff'; ctx.shadowBlur=10;
            ctx.fillStyle='#00ffff'; ctx.beginPath();
            ctx.moveTo(-10,-6); ctx.lineTo(10,0); ctx.lineTo(-10,6); ctx.closePath(); ctx.fill();
            ctx.restore();
        }
    } else if (gameState === 'PLAYING' || gameState === 'BOSS_TRANSITION' || gameState === 'POST_BOSS_TRANSITION' || gameState === 'GET_READY') {
        ctx.save(); ctx.textAlign='center'; ctx.fillStyle='#ffffff'; ctx.shadowColor='#ffffff'; ctx.shadowBlur=10;
        let scoreX = GAME_WIDTH/2, scoreY = 60; if(Math.random()<.05){scoreX+=Math.random()*4-2;scoreY+=Math.random()*4-2;}
        ctx.font='30px "Press Start 2P"'; ctx.fillText(score,scoreX,scoreY);
        ctx.font='15px "Press Start 2P"'; ctx.shadowBlur=5; ctx.fillText(`Coins: ${stats.totalCoins}`, GAME_WIDTH/2,90);
        ctx.restore();
    }

    if (gameState === 'BOSS_TRANSITION') {
        ctx.save(); ctx.textAlign='center'; ctx.fillStyle = `rgba(255,0,0,${Math.abs(Math.sin(frame*0.1))})`;
        ctx.shadowColor='#ff0000'; ctx.shadowBlur = 20;
        ctx.font='30px "Press Start 2P"'; ctx.fillText('WARNING', GAME_WIDTH/2, GAME_HEIGHT/2 - 40);
        ctx.font='50px "Press Start 2P"';
        ctx.fillText(Math.ceil(transitionTimer/60), GAME_WIDTH/2, GAME_HEIGHT/2 + 20);
        ctx.restore();
    } else if (gameState === 'POST_BOSS_TRANSITION' && transitionTimer > 120) {
        ctx.save();
        ctx.textAlign = 'center';
        ctx.fillStyle = `rgba(0,255,255,${Math.abs(Math.sin(frame * 0.1))})`;
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 20;
        ctx.font = '30px "Press Start 2P"';
        ctx.fillText('STAGE CLEARED', GAME_WIDTH / 2, GAME_HEIGHT / 2);
        ctx.restore();
    } else if (gameState === 'GET_READY') {
        ctx.save();
        ctx.textAlign = 'center';
        ctx.fillStyle = `rgba(255,255,255,${Math.abs(Math.sin(frame * 0.05))})`;
        ctx.shadowColor = '#ffffff';
        ctx.shadowBlur = 10;
        ctx.font = '24px "Press Start 2P"';
        ctx.fillText('TAP TO START', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 100);
        ctx.restore();
    }
}
function drawWarpGrid(ctx) {
    ctx.save();ctx.strokeStyle='rgba(0,255,255,.2)';ctx.lineWidth=1;ctx.shadowColor='#00ffff';ctx.shadowBlur=5;for(let i=0;i<GAME_WIDTH;i+=40){ctx.beginPath();for(let j=0;j<GAME_HEIGHT;j++){const x=i+Math.sin(j*.05+frame*.05)*5;if(j===0)ctx.moveTo(x,j);else ctx.lineTo(x,j);}ctx.stroke();}
    for(let i=0;i<GAME_HEIGHT;i+=40){ctx.beginPath();for(let j=0;j<GAME_WIDTH;j++){const y=i+Math.sin(j*.05+frame*.05)*5;if(j===0)ctx.moveTo(j,y);else ctx.lineTo(j,y);}ctx.stroke();}ctx.restore();
}
function checkCollisions() {
    if (player.invincible) return false;
    for (const p of pipes) {
        if (player.x < p.x + p.width + 5 && player.x + player.width > p.x - 5) {
            if (player.y < p.top || player.y + player.height > p.bottom) {
                if (player.breakShield()) return false;
                return true;
            }
        }
    }
    if (player.y + player.height >= GAME_HEIGHT || player.y <= 0) { 
        if (player.breakShield()) { 
            if (player.y <= 0) player.y = 1;
            if (player.y + player.height >= GAME_HEIGHT) player.y = GAME_HEIGHT - player.height - 1;
            player.vy *= -0.5;
            return false; 
        } 
        return true; 
    }
    return false;
}

function gameOver() {
    stats.lastScore = score;
    stats.totalCoins += coinsCollectedThisRun;
    stats.currentScore = 0;
    stats.currentShieldHp = 0;
    saveStats(); 
    gameState = 'UPGRADE'; 
    updateMusicByGameState();
    updateUpgradeUI();
    triggerScreenShake(20, 20);
    for(let i=0; i<100; i++) particles.push(new Particle(player.x, player.y, '#ff007f', Math.random() * 5, 80));
}

function resetGame() { 
    player = new Player(stats.shieldLevel); 
    pipes = []; collectibles = []; particles = []; floatingTexts = [];
    coinsCollectedThisRun = 0; 
    nextPipeFrame = frame + 60; 
    bossFightTriggeredForScore = -1; 
    screenShake = { intensity: 0, duration: 0 };
}

function startRound() {
    resetGame();
    if (stats.currentScore === 0) {
        player.shieldHp = stats.shieldLevel;
    } else {
        player.shieldHp = stats.currentShieldHp;
    }
    score = stats.currentScore;
    player.y = GAME_HEIGHT / 2 - player.height / 2;
    gameState = 'GET_READY';
    updateMusicByGameState();
}

// --- Main Game Loop ---
let player = new Player(0);
const buttons = {};
function isInside(x, y, rect) {
    return rect && x > rect.x && x < rect.x + rect.width && y > rect.y && y < rect.y + rect.height;
}

function handleTitleState() {
    player.update();
    player.draw(ctx);
    
    ctx.save();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    ctx.font = '38px "Press Start 2P"';
    ctx.fillStyle = `hsl(${frame % 360}, 100%, 70%)`;
    ctx.shadowColor = `hsl(${frame % 360}, 100%, 70%)`;
    ctx.shadowBlur = 20 + Math.sin(frame * 0.1) * 5;
    ctx.fillText('Rogue Flap', GAME_WIDTH/2, GAME_HEIGHT/2 - 80);
    
    ctx.font = '15px "Press Start 2P"';
    ctx.fillStyle = '#00ffff';
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 10;
    ctx.fillText('Vector Overdrive', GAME_WIDTH/2, GAME_HEIGHT/2 - 40);

    drawButton(ctx, 'Start Game', GAME_WIDTH/2, GAME_HEIGHT/2 + 50, 240, 50, 'start');
    drawButton(ctx, 'Options', GAME_WIDTH/2, GAME_HEIGHT/2 + 120, 200, 40, 'options');
    ctx.restore();
}

function handleGetReadyState() {
    player.update();
    player.draw(ctx);
}

function drawButton(ctx, text, x, y, width, height, key) {
    const color = '#ff00ff';
    ctx.save();
    ctx.strokeStyle = color;
    ctx.shadowColor = color;
    ctx.shadowBlur = 10;
    ctx.lineWidth = 2;
    ctx.strokeRect(x - width/2, y - height/2, width, height);
    ctx.fillStyle = `rgba(255, 0, 255, ${Math.abs(Math.sin(frame*0.02)) * 0.1 + 0.1})`;
    ctx.fillRect(x - width/2, y - height/2, width, height);
    
    ctx.fillStyle = color;
    ctx.font = '20px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x, y);
    ctx.restore();
    buttons[key] = {x: x - width/2, y: y - height/2, width, height};
}


function resizeCanvas() {
    const ratio = GAME_WIDTH / GAME_HEIGHT;
    const newWidth = window.innerWidth;
    const newHeight = window.innerHeight;
    const newRatio = newWidth / newHeight;

    if (newRatio > ratio) {
        scale = newHeight / GAME_HEIGHT;
    } else {
        scale = newWidth / GAME_WIDTH;
    }

    canvas.width = newWidth;
    canvas.height = newHeight;

    offsetX = (newWidth - (GAME_WIDTH * scale)) / 2;
    offsetY = (newHeight - (GAME_HEIGHT * scale)) / 2;
}

function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);

    if(screenShake.duration > 0) {
        const intensity = screenShake.intensity * (screenShake.duration / 10);
        ctx.translate(Math.random() * intensity - intensity/2, Math.random() * intensity - intensity/2);
        screenShake.duration--;
    }
    
    drawWarpGrid(ctx);
    stars.forEach(s => { s.update(); s.draw(ctx); });
    
    // Manage HTML overlay visibility
    upgradeScreen.style.display = gameState === 'UPGRADE' ? 'flex' : 'none';
    optionsScreen.style.display = gameState === 'OPTIONS' ? 'flex' : 'none';

    if (gameState === 'TITLE') {
        handleTitleState();
    } else if (gameState === 'OPTIONS') {
        player.update();
        player.draw(ctx);
    } else if (gameState === 'UPGRADE') {
        player.update();
        player.draw(ctx);
    } else if (gameState === 'GET_READY') {
        handleGetReadyState();
    } else if (gameState === 'PLAYING') {
        handlePlayingState();
    } else if (gameState === 'BOSS') {
        handleBossState();
    } else if (gameState === 'BOSS_TRANSITION') {
        handleBossTransitionState();
    } else if (gameState === 'POST_BOSS_TRANSITION') {
        handlePostBossTransitionState();
    }
    
    drawHud();
    particles.forEach(p => { p.update(); p.draw(ctx); });
    particles = particles.filter(p => p.life > 0);
    floatingTexts.forEach(t => { t.update(); t.draw(ctx); });
    floatingTexts = floatingTexts.filter(t => t.life > 0);
    
    ctx.restore();
    
    frame++;
    
    requestAnimationFrame(animate);
}

window.addEventListener('resize', resizeCanvas);
loadStats();
loadAudioSettings();
updateUpgradeUI();
resizeCanvas();
animate();
</script>
</body>
</html>
